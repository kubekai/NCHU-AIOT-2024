import pandas as pd
from statsmodels.tsa.ar_model import AutoReg
import statsmodels.api as sm
import matplotlib.pyplot as plt
import os
from flask import Flask, render_template, jsonify, request
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score
import numpy as np
import base64
from io import BytesIO

app = Flask(__name__)
DATA_FILE_PATH = './HW1-2/data.csv'
UPLOAD_FOLDER = os.path.abspath('./HW1-2/uploads')  # Use absolute path
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

@app.route('/')
def index():
    return render_template('index.html')

def create_funnel_plot_data(data, model_type, max_dates=30):
    """
    Create data required for the funnel plot, using prediction values and dates.
    Only display data for the last max_dates days to avoid overcrowding the chart.
    Returns stage names along with their corresponding values and conversion rates.
    """
    # Ensure data is sorted by date
    data = data.sort_values('Date')

    # Select the most recent max_dates days
    if len(data) > max_dates:
        data = data.tail(max_dates)
    
    # Use dates as stages
    stages = data['Date'].dt.strftime('%Y-%m-%d').tolist()
    values = data['y'].tolist()
    
    # Calculate conversion rates (percentage change compared to the previous day)
    conversion_rates = [100]  # Set the conversion rate for the first date to 100%
    for i in range(1, len(values)):
        if values[i-1] != 0:
            rate = (values[i] / values[i-1]) * 100
        else:
            rate = 0
        conversion_rates.append(rate)
    
    # Return only the necessary data
    funnel_data = {
        'stages': stages,
        'values': values,
        'conversion_rates': conversion_rates,
        'model_type': model_type,
        'recent_days': len(data)
    }
    return funnel_data

@app.route('/predict', methods=['POST'])
def predict():
    # Get model type
    model_type = request.form.get('model_type')

    # Read the CSV file
    df = pd.read_csv(DATA_FILE_PATH)

    # Process DataFrame
    df.columns = df.columns.str.strip()
    if 'Date' in df.columns:
        df['Date'] = pd.to_datetime(df['Date'])
        df = df.sort_values('Date')

        if 'y' in df.columns:
            df['y'] = pd.to_numeric(df['y'], errors='coerce')
            df = df.dropna(subset=['y'])

            # Create lag features
            for lag in range(1, 4):  # Create lag features for 1 to 3 days
                df[f'y_lag_{lag}'] = df['y'].shift(lag)
            df['y_ma'] = df['y'].rolling(window=3).mean()  # 3-day moving average

            # Drop NaN values generated by lagging and rolling operations
            df = df.dropna()

            # Split data into training and testing sets
            train, test = train_test_split(df, test_size=0.2, random_state=42, shuffle=False)

            if model_type == 'AR':
                # Fit autoregressive model
                model_ar = AutoReg(train['y'], lags=3)
                model_fit_ar = model_ar.fit()

                # Make predictions using the autoregressive model
                predictions_ar = model_fit_ar.predict(start=len(train), end=len(train) + len(test) - 1)

                # Calculate prediction intervals for the autoregressive model
                residuals_ar = train['y'] - model_fit_ar.fittedvalues
                std_error_ar = np.std(residuals_ar)
                ci_ar = 1.96 * std_error_ar  # 95% confidence interval multiplier

                # Create prediction bounds
                lower_bounds_ar = predictions_ar - ci_ar
                upper_bounds_ar = predictions_ar + ci_ar

                # Model evaluation
                mse_ar = mean_squared_error(test['y'], predictions_ar)
                r2_ar = r2_score(test['y'], predictions_ar)

                # Print evaluation metrics (for debugging)
                print(f'Mean Squared Error (AR): {mse_ar}')
                print(f'R^2 Score (AR): {r2_ar}')

                # Prepare future dates for plotting
                future_dates = pd.date_range(start=df['Date'].iloc[-len(test):].values[-1] + pd.Timedelta(days=1), periods=len(test))

                # Visualization for the autoregressive model
                plt.figure(figsize=(10, 5))
                plt.plot(df['Date'], df['y'], label='Historical Data', marker='o')
                plt.plot(future_dates, predictions_ar, label='AR Predictions', marker='o', color='orange')
                plt.fill_between(future_dates, lower_bounds_ar, upper_bounds_ar, color='gray', alpha=0.5, label='95% Prediction Interval')
                plt.legend()
                plt.title('Autoregressive Model Predictions and Prediction Interval')
                plt.xlabel('Time')
                plt.ylabel('y Value')
                plt.xticks(rotation=45)
                plt.tight_layout()

                # Save AR plot to BytesIO object
                img1 = BytesIO()
                plt.savefig(img1, format='png')
                img1.seek(0)
                plt.close()
                plot_url_ar = base64.b64encode(img1.getvalue()).decode()

                # Create a DataFrame for prediction data
                pred_df_ar = pd.DataFrame({
                    'Date': future_dates,
                    'y': predictions_ar
                })

                # Generate funnel plot data based on prediction data for the autoregressive model
                funnel_data_ar = create_funnel_plot_data(pred_df_ar, 'AR Prediction')

                return jsonify({
                    'plot_url_ar': plot_url_ar,
                    'funnel_data_ar': funnel_data_ar,
                    'mse_ar': mse_ar,
                    'r2_ar': r2_ar
                })

            elif model_type == 'ML':
                # Fit multiple linear regression model
                X_train = train[[f'y_lag_{lag}' for lag in range(1, 4)]]
                X_train = sm.add_constant(X_train)  # Add intercept term
                model_ml = sm.OLS(train['y'], X_train).fit()

                # Prepare testing data for predictions
                X_test = test[[f'y_lag_{lag}' for lag in range(1, 4)]]
                X_test = sm.add_constant(X_test)

                # Make predictions using the multiple linear regression model
                predictions_ml = model_ml.predict(X_test)

                # Calculate prediction intervals for multiple linear regression
                residuals_ml = train['y'] - model_ml.predict(X_train)
                std_error_ml = np.std(residuals_ml)
                ci_ml = 1.96 * std_error_ml  # 95% confidence interval multiplier

                # Create prediction bounds
                lower_bounds_ml = predictions_ml - ci_ml
                upper_bounds_ml = predictions_ml + ci_ml

                # Model evaluation
                mse_ml = mean_squared_error(test['y'], predictions_ml)
                r2_ml = r2_score(test['y'], predictions_ml)

                # Print evaluation metrics (for debugging)
                print(f'Mean Squared Error (ML): {mse_ml}')
                print(f'R^2 Score (ML): {r2_ml}')

                # Prepare future dates for plotting
                future_dates = pd.date_range(start=df['Date'].iloc[-len(test):].values[-1] + pd.Timedelta(days=1), periods=len(test))

                # Visualization for the multiple linear regression model
                plt.figure(figsize=(10, 5))
                plt.plot(df['Date'], df['y'], label='Historical Data', marker='o')
                plt.plot(future_dates, predictions_ml, label='ML Predictions', marker='o', color='green')
                plt.fill_between(future_dates, lower_bounds_ml, upper_bounds_ml, color='lightgray', alpha=0.5, label='95% Confidence Interval')
                plt.legend()
                plt.title('Multiple Linear Regression Model Predictions and Prediction Interval')
                plt.xlabel('Time')
                plt.ylabel('y Value')
                plt.xticks(rotation=45)
                plt.tight_layout()

                # Save ML plot to BytesIO object
                img2 = BytesIO()
                plt.savefig(img2, format='png')
                img2.seek(0)
                plt.close()
                plot_url_ml = base64.b64encode(img2.getvalue()).decode()

                # Create a DataFrame for prediction data
                pred_df_ml = pd.DataFrame({
                    'Date': future_dates,
                    'y': predictions_ml
                })

                # Generate funnel plot data based on prediction data for the multiple linear regression model
                funnel_data_ml = create_funnel_plot_data(pred_df_ml, 'ML Prediction')

                return jsonify({
                    'plot_url_ml': plot_url_ml,
                    'funnel_data_ml': funnel_data_ml,
                    'mse_ml': mse_ml,
                    'r2_ml': r2_ml
                })

            else:
                return jsonify({'error': "Invalid model_type. Use 'AR' or 'ML'."}), 400
        else:
            return jsonify({'error': "Column 'y' not found in the data."}), 400
    else:
        return jsonify({'error': "Column 'Date' not found in the data."}), 400

if __name__ == '__main__':
    app.run(debug=True)
